[{"C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\index.js":"1","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\App.js":"2","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\serviceWorker.js":"3","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\generator\\generator.js":"4","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\QasmStuff\\qasm_Converter.js":"5","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\QasmStuff\\QASM_generator.js":"6","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\blocks\\customblocks.js":"7","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\Blockly\\index.js":"8","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\Blockly\\BlocklyComponent.jsx":"9"},{"size":464,"mtime":1654422671412,"results":"10","hashOfConfig":"11"},{"size":3116,"mtime":1656921475100,"results":"12","hashOfConfig":"11"},{"size":5086,"mtime":1650862256445,"results":"13","hashOfConfig":"11"},{"size":11571,"mtime":1656319618836,"results":"14","hashOfConfig":"11"},{"size":1800,"mtime":1656921467538,"results":"15","hashOfConfig":"11"},{"size":29528,"mtime":1654429584965,"results":"16","hashOfConfig":"11"},{"size":17526,"mtime":1656319506293,"results":"17","hashOfConfig":"11"},{"size":1715,"mtime":1650862256437,"results":"18","hashOfConfig":"11"},{"size":2155,"mtime":1655806833988,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"11wnb0",{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"25","messages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"22"},{"filePath":"30","messages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":2,"source":null},{"filePath":"32","messages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"22"},{"filePath":"35","messages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"37","messages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\index.js",[],["41","42"],"C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\App.js",["43","44","45","46"],"C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\serviceWorker.js",[],"C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\generator\\generator.js",["47","48","49","50","51","52","53","54","55","56","57"],"import * as Blockly from 'blockly/core';\r\nimport 'blockly/javascript';\r\nimport {generate_QASM, \r\n  built_in_gate_block, \r\n  var_def_block, \r\n  var_ref_block, \r\n  var_assignment_block, \r\n  measurement_block,\r\n  if_block, \r\n  expression_block,\r\n  loop_block,\r\n  custom_function_def,\r\n  custom_function_ref,\r\n  n_bit_controlled_gate} from '../QasmStuff/QASM_generator.js';\r\n\r\n\r\nconst blocks = [];\r\nexport default blocks\r\n\r\nBlockly.JavaScript['test_addition'] = function(block) {\r\n    var value_x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC);\r\n    // TODO: Assemble JavaScript into code variable.\r\n    var code = value_x + ' + ' + value_y;\r\n    // TODO: Change ORDER_NONE to the correct strength.\r\n    return [code, Blockly.JavaScript.ORDER_NONE];\r\n  };\r\n\r\nBlockly.JavaScript['param_input'] = function(block) {\r\n  var text__paraminput = block.getFieldValue(' ParamInput');\r\n  // TODO: Assemble JavaScript into code variable.\r\n  var code = text__paraminput;\r\n  // TODO: Change ORDER_NONE to the correct strength.\r\n  return [code, Blockly.JavaScript.ORDER_ATOMIC];\r\n};\r\n\r\nBlockly.JavaScript['test_one'] = function(block) {\r\n    var text_num = block.getFieldValue('NUM');\r\n    // TODO: Assemble JavaScript into code variable.\r\n    var code = text_num;\r\n    // TODO: Change ORDER_NONE to the correct strength.\r\n    return [code, Blockly.JavaScript.ORDER_ATOMIC];\r\n  };\r\n\r\n  Blockly.JavaScript['test_input'] = function(block) {\r\n    var dropdown_drop = block.getFieldValue('DROP');\r\n    // TODO: Assemble JavaScript into code variable.\r\n    var code = dropdown_drop;\r\n    // TODO: Change ORDER_NONE to the correct strength.\r\n    return [code, Blockly.JavaScript.ORDER_ATOMIC];\r\n  };\r\n\r\n  Blockly.JavaScript['test_x_gate'] = function(block) {\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC); \r\n    blocks.push(new built_in_gate_block('x', Math.random, [], [parseInt(value_qubit)]));\r\n    // console.log(blocks)\r\n    // console.log(generate_QASM(blocks, value_qubit))\r\n    return \"X\";\r\n    \r\n  };\r\n\r\n  Blockly.JavaScript['test_y_gate'] = function(block) {\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('y', Math.random, [], [parseInt(value_qubit)]));\r\n    // console.log(blocks)\r\n    // console.log(generate_QASM(blocks, value_qubit))\r\n    return \"Y\";\r\n  };\r\n\r\n  Blockly.JavaScript['test_z_gate'] = function(block) {\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('z', Math.random, [], [parseInt(value_qubit)]));\r\n    // console.log(blocks)\r\n    // console.log(generate_QASM(blocks, value_qubit))\r\n    return \"Z\";\r\n  };\r\n\r\n  Blockly.JavaScript['test_hadamard_gate'] = function(block) {\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('h', Math.random, [], [parseInt(value_qubit)]));\r\n    // console.log(blocks)\r\n    // console.log(generate_QASM(blocks, value_qubit))\r\n    return \"H\";\r\n  };\r\n\r\n  Blockly.JavaScript['u3_gate'] = function(block) {\r\n    var value_param_1 = Blockly.JavaScript.valueToCode(block, 'Param 1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_param_2 = Blockly.JavaScript.valueToCode(block, 'Param 2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_param_3 = Blockly.JavaScript.valueToCode(block, 'Param 3', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('u3', Math.random, [parseInt(value_param_1), parseInt(value_param_2), parseInt(value_param_3)], [parseInt(value_qubit)]));;\r\n    return \"U3\";\r\n  }\r\n\r\n  Blockly.JavaScript['u2_gate'] = function(block) {\r\n    var value_param_1 = Blockly.JavaScript.valueToCode(block, 'Param 1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_param_2 = Blockly.JavaScript.valueToCode(block, 'Param 2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('u2', Math.random, [parseInt(value_param_1), parseInt(value_param_2)], [parseInt(value_qubit)]));;\r\n    return \"U2\";\r\n  };\r\n\r\n  Blockly.JavaScript['u1_gate'] = function(block) {\r\n    var value_param_1 = Blockly.JavaScript.valueToCode(block, 'Param 1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('u1', Math.random, [parseInt(value_param_1)], [parseInt(value_qubit)]));;\r\n    return \"U1\";\r\n  };\r\n\r\n  Blockly.JavaScript['cx_gate'] = function(block) {\r\n    var value_qubit_1 = Blockly.JavaScript.valueToCode(block, 'Qubit-1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_2 = Blockly.JavaScript.valueToCode(block, 'Qubit-2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('cx', Math.random, [], [parseInt(value_qubit_1), parseInt(value_qubit_2)]));\r\n    return \"CX\";\r\n  };\r\n\r\n  Blockly.JavaScript['id_gate'] = function(block) {\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('id', Math.random, [], [parseInt(value_qubit)]));\r\n    return \"ID\";\r\n  };\r\n\r\n  Blockly.JavaScript['s_gate'] = function(block) {\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('s', Math.random, [], [parseInt(value_qubit)]));\r\n    return \"S\";\r\n  };\r\n\r\n  Blockly.JavaScript['sdg_gate'] = function(block) {\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('sdg', Math.random, [], [parseInt(value_qubit)]));\r\n    return \"SDG\";\r\n  };\r\n\r\n  Blockly.JavaScript['t_gate'] = function(block) {\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('t', Math.random, [], [parseInt(value_qubit)]));\r\n    return \"T\";\r\n  };\r\n\r\n  Blockly.JavaScript['tdg_gate'] = function(block) {\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('tdg', Math.random, [], [parseInt(value_qubit)]));\r\n    return \"TDG\";\r\n  };\r\n\r\n  Blockly.JavaScript['rx_gate'] = function(block) {\r\n    var value_param_1 = Blockly.JavaScript.valueToCode(block, 'Param 1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('rx', Math.random, [parseInt(value_param_1)], [parseInt(value_qubit)]));;\r\n    return \"RX\";\r\n  };\r\n\r\n  Blockly.JavaScript['ry_gate'] = function(block) {\r\n    var value_param_1 = Blockly.JavaScript.valueToCode(block, 'Param 1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('ry', Math.random, [parseInt(value_param_1)], [parseInt(value_qubit)]));;\r\n    return \"RY\";\r\n  };\r\n\r\n  Blockly.JavaScript['rz_gate'] = function(block) {\r\n    var value_param_1 = Blockly.JavaScript.valueToCode(block, 'Param 1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit = Blockly.JavaScript.valueToCode(block, 'Qubit', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('rz', Math.random, [parseInt(value_param_1)], [parseInt(value_qubit)]));;\r\n    return \"RZ\";\r\n  };\r\n\r\n  Blockly.JavaScript['cz_gate'] = function(block) {\r\n    var value_qubit_1 = Blockly.JavaScript.valueToCode(block, 'Qubit-1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_2 = Blockly.JavaScript.valueToCode(block, 'Qubit-2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('cz', Math.random, [], [parseInt(value_qubit_1),parseInt(value_qubit_2)]));\r\n    return \"CZ\";\r\n  };\r\n\r\n  Blockly.JavaScript['cy_gate'] = function(block) {\r\n    var value_qubit_1 = Blockly.JavaScript.valueToCode(block, 'Qubit-1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_2 = Blockly.JavaScript.valueToCode(block, 'Qubit-2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('cy', Math.random, [], [parseInt(value_qubit_1),parseInt(value_qubit_2)]));\r\n    return \"CY\";\r\n  };\r\n\r\n  Blockly.JavaScript['ch_gate'] = function(block) {\r\n    var value_qubit_1 = Blockly.JavaScript.valueToCode(block, 'Qubit-1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_2 = Blockly.JavaScript.valueToCode(block, 'Qubit-2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('ch', Math.random, [], [parseInt(value_qubit_1),parseInt(value_qubit_2)]));\r\n    return \"CH\";\r\n  };\r\n\r\n  Blockly.JavaScript['crz_gate'] = function(block) {\r\n    var value_param_1 = Blockly.JavaScript.valueToCode(block, 'Param 1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_1 = Blockly.JavaScript.valueToCode(block, 'Qubit-1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_2 = Blockly.JavaScript.valueToCode(block, 'Qubit-2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('crz', Math.random, [parseInt(value_param_1)], [parseInt(value_qubit_1), parseInt(value_qubit_2)]));;\r\n    return \"CRZ\";\r\n  };\r\n\r\n  Blockly.JavaScript['cu1_gate'] = function(block) {\r\n    var value_param_1 = Blockly.JavaScript.valueToCode(block, 'Param 1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_1 = Blockly.JavaScript.valueToCode(block, 'Qubit-1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_2 = Blockly.JavaScript.valueToCode(block, 'Qubit-2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('cu1', Math.random, [parseInt(value_param_1)], [parseInt(value_qubit_1), parseInt(value_qubit_2)]));;\r\n    return \"CU1\";\r\n  };\r\n\r\n  Blockly.JavaScript['cu3_gate'] = function(block) {\r\n    var value_param_1 = Blockly.JavaScript.valueToCode(block, 'Param 1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_param_2 = Blockly.JavaScript.valueToCode(block, 'Param 2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_param_3 = Blockly.JavaScript.valueToCode(block, 'Param 3', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_1 = Blockly.JavaScript.valueToCode(block, 'Qubit-1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_2 = Blockly.JavaScript.valueToCode(block, 'Qubit-2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('cu3', Math.random, [parseInt(value_param_1), parseInt(value_param_2), parseInt(value_param_3)], [parseInt(value_qubit_1), parseInt(value_qubit_2)]));;\r\n    return \"CU3\";\r\n  };\r\n\r\n  Blockly.JavaScript['ccx_gate'] = function(block) {\r\n    var value_qubit_1 = Blockly.JavaScript.valueToCode(block, 'Qubit_1', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_2 = Blockly.JavaScript.valueToCode(block, 'Qubit_2', Blockly.JavaScript.ORDER_ATOMIC);\r\n    var value_qubit_3 = Blockly.JavaScript.valueToCode(block, 'Qubit_3', Blockly.JavaScript.ORDER_ATOMIC);\r\n    blocks.push(new built_in_gate_block('ccx', Math.random, [0], [parseInt(value_qubit_1),parseInt(value_qubit_2),parseInt(value_qubit_3)]));\r\n    return \"CCX\";\r\n  };\r\n  ","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\QasmStuff\\qasm_Converter.js",["58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73"],"C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\QasmStuff\\QASM_generator.js",["74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89"],"// variables - list, can refer to qubits, classical bits or angles - ints, qubits or angles\r\n// control block, will conditionally execute a gate based off the state of other qubits, cannot be the same ones\r\n// measurement block - measures a number of qubits, records the result in a classical bit for each qubit\r\n// custom blocks/gates - takes a list of qubits and a list of gates, does some operations on them\r\n\r\n\r\n\r\n\r\nconst built_in_gates = \r\n{\r\n    h: {\r\n        gate_name: \"Hadamard\",\r\n        num_parameters: 0, //parameters that would be inside brackets e.g u(pi)\r\n        num_qubit_operands: 1,   //num of qubits that the block operates on\r\n        QASM_symbol: \"h\"\r\n    },\r\n    u3:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 3,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"u3\"\r\n    },\r\n    u2:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 2,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"u2\"\r\n    },\r\n    u1:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 1,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"u1\"\r\n    },\r\n    cx:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 2,\r\n        QASM_symbol: \"cx\"\r\n    },\r\n    id:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"id\"\r\n    },\r\n    x:\r\n    {\r\n        gate_name: \"Not\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"x\"\r\n    },\r\n    y:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"y\"\r\n    },\r\n    z:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"z\"\r\n    },\r\n    s:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"s\"\r\n    },\r\n    sdg:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"sdg\"\r\n    },\r\n    t:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"t\"\r\n    },\r\n    tdg:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"tdg\"\r\n    },\r\n    rx:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 1,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"rx\"\r\n    },\r\n    ry:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 1,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"ry\"\r\n    },\r\n    rz:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 1,\r\n        num_qubit_operands: 1,\r\n        QASM_symbol: \"rz\"\r\n    },\r\n    cz:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 2,\r\n        QASM_symbol: \"cz\"\r\n    },\r\n    cy:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 2,\r\n        QASM_symbol: \"cy\"\r\n    },\r\n    ch:\r\n    {\r\n        gate_name: \"controlled-H\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 2,\r\n        QASM_symbol: \"ch\"\r\n    },\r\n    ccx:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 0,\r\n        num_qubit_operands: 3,\r\n        QASM_symbol: \"ccx\"\r\n    },\r\n    crz:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 1,\r\n        num_qubit_operands: 2,\r\n        QASM_symbol: \"crz\"\r\n    },\r\n    cu1:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 1,\r\n        num_qubit_operands: 2,\r\n        QASM_symbol: \"cu1\"\r\n    },\r\n    cu3:\r\n    {\r\n        gate_name: \"\",\r\n        num_parameters: 3,\r\n        num_qubit_operands: 2,\r\n        QASM_symbol: \"cu3\"\r\n    }\r\n\r\n}\r\n\r\nconst var_types = \r\n{\r\n    int: \"integer\",\r\n    int_list: \"integer_list\",\r\n    angle: \"angle\",\r\n    angle_list: \"angle_list\"\r\n}\r\n\r\nconst block_types = \r\n{\r\n    built_in_gate: \"built_in_gate\",\r\n    variable_def: \"variable_def\",\r\n    variable_ref: \"variable_ref\",\r\n    var_assignment: \"var_assignment\",\r\n    measurement: \"measurement\",\r\n    expression: \"expression\",\r\n    if: \"if\",\r\n    loop: \"loop\",\r\n    custom_function_def: \"custom_function_def\",\r\n    custom_function_ref: \"custom_function_ref\",\r\n    n_bit_toffoli: \"n_bit_toffoli\"\r\n}\r\n\r\nclass block\r\n{\r\n    constructor(block_name, block_id)\r\n    {\r\n        this.block_name = block_name;\r\n        this.block_id = block_id;\r\n    }\r\n\r\n}\r\n\r\nclass built_in_gate_block extends block\r\n{\r\n    constructor(block_name, block_id, parameters, qubit_operands)\r\n    {\r\n        super(block_name, block_id);\r\n        this.parameters = parameters;\r\n        this.qubit_operands = qubit_operands;\r\n        this.block_type = block_types.built_in_gate;\r\n    }\r\n}\r\n\r\n// variable can be either a list or a single value\r\n// if var_type is \"angle_list\" or \"integer_list\", it must be an array\r\n// if var_type is \"angle\" or \"integer\", it must be a single value\r\nclass var_def_block extends block\r\n{\r\n    constructor(block_name, block_id, var_type, value = 0)\r\n    {\r\n        super(block_name, block_id);\r\n        this.var_type = var_type;\r\n        this.value = value;\r\n        this.block_type = block_types.variable_def;\r\n    }\r\n}\r\n\r\n// refers to a variable that's already defined\r\nclass var_ref_block extends block\r\n{\r\n    constructor(block_name, block_id)\r\n    {\r\n        super(block_name, block_id);\r\n        this.block_type = block_types.variable_ref;\r\n    }\r\n}\r\n\r\n// an operation that modifies the value of a variable\r\n// lhs is the left hand side of the assignment, a variable reference\r\n// rhs is the right hand side of the equation, evaluates to a value\r\nclass var_assignment_block extends block\r\n{\r\n    constructor(block_name, block_id, lhs, rhs)\r\n    {\r\n        super(block_name, block_id);\r\n        this.lhs = lhs; // should be a variable reference\r\n        this.rhs = rhs; // should evaluate to a value of the same type as lhs\r\n        this.block_type = block_types.var_assignment;\r\n    }\r\n}\r\n\r\n// a measurement on qubits that gets saved into cregs\r\nclass measurement_block extends block\r\n{\r\n    constructor(block_name, block_id, qubit_operands, measure_all=false)\r\n    {\r\n        super(block_name, block_id);\r\n        this.qubit_operands = qubit_operands;\r\n        this.measure_all = measure_all;\r\n        this.block_type = block_types.measurement;\r\n    }\r\n}\r\n\r\n\r\n\r\n// operator: a string, e.g \"+\", \"-\", \r\n// operands: 2 values, var_ref_blocks, or expression_blocks that the operator will act on\r\n// operands should refer/evaluate to the same type\r\n// this is expected to be used in the right hand side of an assignment block\r\nclass expression_block extends block\r\n{\r\n    constructor(block_name, block_id, operator, operands)\r\n    {\r\n        super(block_name, block_id);\r\n        this.operator = operator;\r\n        this.operands = operands;\r\n        this.block_type = block_types.expression;\r\n    }\r\n\r\n}\r\n\r\n// values is an array containing the value to compare the if  astatementgainst\r\n// multiple values may be supported in the future\r\n// gate is the gate block to be executed if the condition is true \r\n// multiple gates may be supported in the future\r\nclass if_block extends block\r\n{\r\n    constructor(block_name, block_id, values, gate)\r\n    {\r\n        super(block_name, block_id);\r\n        this.values = values;\r\n        this.gate = gate;\r\n        this.block_type = block_types.if;\r\n    }\r\n}    \r\n\r\n\r\nclass loop_block extends block\r\n{\r\n    constructor(block_name, block_id, num_loops, blocks)\r\n    {\r\n        super(block_name, block_id);\r\n        this.num_loops = num_loops;\r\n        this.blocks = blocks;\r\n        this.block_type = block_types.loop;\r\n    }\r\n}\r\n\r\n// currently params and operands do nothing and everything must exist hardcoded within the blocks\r\nclass custom_function_def extends block\r\n{\r\n    constructor(block_name, block_id, num_params, num_operands, blocks)\r\n    {\r\n        super(block_name, block_id);\r\n        this.num_params = num_params;\r\n        this.num_operands = num_operands;\r\n        this.blocks = blocks;\r\n        this.block_type = block_types.custom_function_def;\r\n    }\r\n}\r\n\r\n// currently params and operands do nothing\r\nclass custom_function_ref extends block\r\n{\r\n    constructor(block_name, block_id, params, operands)\r\n    {\r\n        super(block_name, block_id);\r\n        this.params = params;\r\n        this.operands = operands;\r\n        this.block_type = block_types.custom_function_ref;\r\n    }\r\n}\r\n\r\n// controls is an array of controls\r\n// anticontrols is an array of anticontrols\r\n// target is a single qubit value\r\nclass n_bit_toffoli extends block\r\n{\r\n    constructor(block_name, block_id, controls, anticontrols, target)\r\n    {\r\n        super(block_name, block_id);\r\n        this.controls = controls;\r\n        this.anticontrols = anticontrols;\r\n        this.target = target;\r\n        this.block_type = block_types.n_bit_toffoli;\r\n    }\r\n}\r\n\r\nconst error_types = \r\n{\r\n    // gate errors\r\n    invalid_gate: \"gate does not exist\",\r\n    invalid_params_len: \"number of parameters does not match expected of parameters\",\r\n    invalid_operands_len: \"number of parameters does not match expected of parameters\",\r\n    invalid_param: \"parameter is not valid\",\r\n    invalid_operand: \"operand is not valid\",\r\n    duplicate_operands: \"duplicate operands\",\r\n\r\n    duplicate_var_defs: \"variable is defined more than once\",\r\n    duplicate_fun_defs: \"function is defined more than once\",\r\n\r\n    unsupported_operator: \"operator is not supported\",\r\n\r\n    invalid_if: \"if block is not valid, check that the value is an integer greater than 0\",\r\n    invalid_loop: \"loop block is not valid, check that loop count is an integer\"\r\n}\r\n\r\nvar errors = [];\r\n\r\n/*\r\n * Takes 2 parameters, blocks representing the code, and the number of qubits in the circuit\r\n * blocks are objects with the following properties:\r\n * block_name - a string containing the name of the block\r\n * block_type - a string containing the type of the block\r\n * parameters - an array of numbers, to be the parameters of the gate, e.g cu3(parameter1, parameter2, parameter3)\r\n * qubit_operands - an array of numbers, representing the qubits that the block operates on, in order.\r\n */\r\nfunction generate_QASM(blocks)\r\n{\r\n    // puts all the variables into this object, with names as the keys.\r\n    // checks for duplicates\r\n    // TODO: possibly check variable dependancies for cycles\r\n    let variables = preprocess_variables(blocks);\r\n\r\n    // clears errors from previous calls\r\n    errors = [];\r\n\r\n    // puts references to functions into functions block, with names as the keys\r\n    let functions = preprocess_functions(blocks);\r\n    console.log(variables);\r\n\r\n    // first value is the qubits in q, the qubits being operated on\r\n    // second value is the qubits in anc, an ancilla qreg\r\n    let num_qubits = [0, 0]; \r\n    \r\n    let qasm = [[\"OPENQASM 2.0;\\ninclude \\\"qelib1.inc\\\";\\n\"]];\r\n    qasm.push([\"qreg q[\"]); // these will be filled in later with the max value of qubits\r\n    qasm.push([\"creg c[\"]);\r\n    qasm.push([\"qreg anc[\"]);\r\n\r\n    // goes over each block, adding their respective qasm to the qasm array\r\n    // 1 is added to num_qubits because it is set to the value of the highest qubit operand but is 0 indexed\r\n    process_blocks(qasm, blocks, variables, num_qubits, functions);\r\n    num_qubits[0] += 1;\r\n    num_qubits[1] += 1;\r\n\r\n    qasm[1][0] += `${num_qubits[0]}];\\n`;\r\n    qasm[2][0] += `${num_qubits[0]}];\\n`;\r\n    qasm[3][0] += `${num_qubits[1]}];\\n`;\r\n    return {qasm,errors};\r\n}\r\n\r\n/*\r\n * qasm is an array that the qasm will be pushed to, each line being an array with a qasm string and block id\r\n * blocks is the blocks to be processed\r\n * variables is a list of key/value pairs that give all the variables their values\r\n * returns the number of qubits (the highest number found inside the blocks as a qubit operand after processing)\r\n * type restrictions restrict the valid types that the blocks can be\r\n */\r\nfunction process_blocks(qasm, blocks, variables, num_qubits, functions, type_restrictions={})\r\n{\r\n    for(let i = 0; i < blocks.length; i++)\r\n    {\r\n\r\n        switch(blocks[i].block_type)\r\n        {\r\n            case block_types.built_in_gate:\r\n            {\r\n                let block = expand_built_in_variables(blocks[i], variables);\r\n                if(block.block_name in built_in_gates)\r\n                {\r\n                    if(is_valid_built_in(block))\r\n                    {\r\n                        num_qubits[0] = Math.max(num_qubits[0], ...block.qubit_operands);\r\n                        qasm.push([built_in_gate_to_QASM(block), block.block_id]);\r\n                    }\r\n                } else \r\n                {\r\n                    errors.push([error_types.invalid_gate, block]);\r\n                }\r\n                break;\r\n            } \r\n            case block_types.var_assignment:   \r\n            {\r\n                // does the variable assignment described in the block\r\n                variable_assignment(blocks[i], variables);\r\n                // console.log(\"Variables after this var assignment are\");\r\n                // console.log(variables);\r\n                break;\r\n            }\r\n            case block_types.measurement:\r\n            {\r\n\r\n                let block = expand_measurement_variables(blocks[i], variables); \r\n\r\n                num_qubits[0] = Math.max(num_qubits[0], ...block.qubit_operands);\r\n                qasm.push([measurement_block_to_qasm(block), block.block_id]);\r\n                break;\r\n            }\r\n            case block_types.if:\r\n            {\r\n                let block = expand_if_variables(blocks[i], variables);\r\n                \r\n                if(is_valid_if_block(block))\r\n                {\r\n                    qasm.push([if_block_to_qasm(block, variables, num_qubits), block.block_id]);\r\n                }\r\n                else\r\n                {\r\n                    errors.push([error_types.invalid_if, block]);\r\n                }\r\n                break;\r\n            }\r\n            case block_types.loop:\r\n            {\r\n                let block = expand_loop_count(blocks[i], variables);\r\n\r\n                if(is_valid_loop_block(block))\r\n                {\r\n                    qasm.push(...loop_block_to_qasm(block, variables, num_qubits));\r\n                } else   \r\n                {\r\n                    errors.push([error_types.invalid_loop, block])\r\n                }\r\n                break;\r\n            }\r\n            case block_types.custom_function_ref:\r\n            {\r\n                let block = functions[blocks[i].block_name];\r\n                console.log(\"functions\");\r\n                console.log(functions);\r\n                \r\n                qasm.push(...custom_function_to_qasm(block, variables, num_qubits, functions));\r\n\r\n\r\n                break;\r\n            }\r\n            case block_types.n_bit_toffoli:\r\n            {\r\n                qasm.push(...n_bit_toffoli_to_qasm(blocks[i], variables, num_qubits));\r\n            }\r\n            default:\r\n                //console.log(\"something went wrong\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/* \r\n * Reads the block name, and finds the corresponding built in gate, and converts it into QASM\r\n * Takes a block as a parameter. \r\n */\r\nfunction built_in_gate_to_QASM(block, qreg=\"q\")\r\n{\r\n    \r\n    let gate = built_in_gates[block.block_name];\r\n\r\n    let gate_qasm = \"\";\r\n    \r\n    gate_qasm += gate.QASM_symbol;\r\n\r\n    // concatenate the parameters, comma separated in brackets. \r\n    if(gate.num_parameters > 0)\r\n    {\r\n        gate_qasm += \"(\" + block.parameters.join() + \")\";\r\n    }\r\n    \r\n    // concatenate the operands, comma separated\r\n    if(gate.num_qubit_operands > 0)\r\n    {\r\n        gate_qasm += ' ';\r\n        gate_qasm += block.qubit_operands.map(operand => `${qreg}[${operand}]`).join(\",\");\r\n    }\r\n    gate_qasm += ';\\n';\r\n\r\n    return gate_qasm;\r\n}\r\n\r\n/*\r\n * Checks if a built in block is valid\r\n * Checks that parameters are between 0 and 2 pi\r\n * Checks that operands are greater than 0, are integers, and do not repeat\r\n * Checks that there are the correct number of operands and parameters\r\n * returns a boolean, true if the built in block is valid, false otherwise\r\n */\r\nfunction is_valid_built_in(block)\r\n{\r\n    let gate = built_in_gates[block.block_name];\r\n\r\n    // check for equality in the number of parameters\r\n    if(gate.num_parameters != block.parameters.length)\r\n    {\r\n        errors.push([error_types.invalid_params_len, block]);\r\n        return false;\r\n    }\r\n\r\n    if(gate.num_qubit_operands !=  block.qubit_operands.length)\r\n    {\r\n        errors.push([error_types.invalid_operands_len, block]);\r\n        return false;\r\n    }\r\n\r\n    // validate the parameters (numbers between 0 and 2 pi)\r\n    for(let parameter of block.parameters)\r\n    {\r\n        if(!is_valid_param(parameter))\r\n        {\r\n            errors.push([error_types.invalid_param, block]);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // checks for duplicate operand values, values less than 0, non int values\r\n    // an object to put operands in, will be checked for duplicates\r\n    let operands = {};\r\n    for(let i = 0; i < block.qubit_operands.length; i++)\r\n    {\r\n        if(!is_valid_qubit_operand(block.qubit_operands[i]))\r\n        {\r\n            errors.push([error_types.invalid_operand, block]);\r\n            return false;\r\n        }\r\n        \r\n        if(block.qubit_operands[i] in operands)\r\n        {  \r\n            errors.push([error_types.duplicate_operands, block]);\r\n            return false;\r\n        } else\r\n        {\r\n            operands[block.qubit_operands[i]] = true;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/*\r\n * takes the array of blocks, puts all the variables into a new object to allow for easier lookup later\r\n * also checks for duplicates of variables \r\n */\r\nfunction preprocess_variables(blocks)\r\n{\r\n    let variables = {};\r\n    for(let i = 0; i < blocks.length; i++)\r\n    {\r\n       \r\n        if(blocks[i].block_type == block_types.variable_def)\r\n        {\r\n            let var_def_block = blocks[i];\r\n\r\n            // check if variable name already exists\r\n            if(var_def_block.block_name in variables)\r\n            {\r\n                errors.push([error_types.duplicate_var_defs, blocks[i]]);\r\n                continue;\r\n            }\r\n\r\n            // assigns variable to object property, with the name being the key, this will be useful to look up the variable later\r\n            variables[var_def_block.block_name] =\r\n            { \r\n                block_id: var_def_block.block_id, \r\n                var_type: var_def_block.var_type,\r\n                value: var_def_block.value\r\n            };\r\n            \r\n        }\r\n        // if variable name in variables, error\r\n    }\r\n    return variables;\r\n}\r\n\r\nfunction preprocess_functions(blocks)\r\n{\r\n    let functions = {};\r\n\r\n    for(let i = 0; i < blocks.length; i++)\r\n    {\r\n        if(blocks[i].block_type == block_types.custom_function_def)\r\n        {\r\n            if(blocks[i].block_name in functions)\r\n            {\r\n                errors.push([error_types.duplicate_fun_defs, blocks[i]]);\r\n                continue;\r\n            }\r\n\r\n            functions[blocks[i].block_name] = blocks[i];\r\n        }\r\n\r\n        \r\n    }\r\n\r\n    console.log(\"preprocessed_functions\");\r\n    console.log(functions);\r\n    return functions;\r\n}\r\n\r\n\r\n/* goes through the blocks parameters and replaces variables with their values\r\n * returns a copy of the block\r\n * operates on built in blocks\r\n * if there are variable references, these are replaced by the value of the variable\r\n * returns a copy of the block with the variables replaced with numbers\r\n * \r\n */\r\nfunction expand_built_in_variables(block, variables)\r\n{\r\n    //creates a copy of the block\r\n    let expanded_block = {};\r\n    copy_block(expanded_block, block);\r\n\r\n    if(\"qubit_operands\" in expanded_block)\r\n    {\r\n        expand_array_vars(expanded_block.qubit_operands, variables, \"integer\");\r\n        \r\n    }// else\r\n    // {\r\n    //     console.log(\"error, block is missing attributes\");\r\n    // }\r\n    \r\n    if(\"parameters\" in expanded_block)\r\n    {\r\n        expand_array_vars(expanded_block.parameters, variables, \"angle\");\r\n    }// else\r\n    // {\r\n    //     console.log(\"error, block is missing attributes\");\r\n    // }\r\n\r\n    return expanded_block;\r\n}\r\n\r\nfunction variable_assignment(block, variables)\r\n{\r\n    console.log(\"block.lhs\");\r\n    console.log(block.lhs);\r\n    console.log(block);\r\n    console.log(\"variables\");\r\n    console.log(variables);\r\n\r\n    let expanded_block = {};\r\n    copy_block(expanded_block, block);\r\n\r\n    \r\n    // finds variable with the given name\r\n    let variable = variables[expanded_block.lhs.block_name];\r\n\r\n\r\n    if(expanded_block.rhs.block_type == block_types.expression)\r\n    {\r\n        // console.log(\"expanded_block.rhs.block_type is expression\");\r\n        // console.log(expanded_block);\r\n        expanded_block.rhs = evaluate_expression_block(expanded_block.rhs, variables, expanded_block.lhs.var_type);\r\n    } else\r\n    {\r\n        // console.log(\"expanded_block.rhs.block_type is not expression, it is \");\r\n        // console.log(expanded_block.rhs.block_type);\r\n        // console.log(\"expanded block\");\r\n        // console.log(expanded_block)\r\n    }\r\n\r\n    variable.value = expanded_block.rhs;\r\n    console.log(variables);\r\n}\r\n\r\nfunction is_valid_param(parameter)\r\n{\r\n\r\n    if(typeof(parameter) != \"number\")\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if(parameter < 0 || parameter > (2 * Math.PI))\r\n    {\r\n        return false;\r\n    }\r\n    return true;\r\n    \r\n}\r\n\r\nfunction is_valid_qubit_operand(qubit_operand)\r\n{\r\n    if(qubit_operand < 0 || !Number.isInteger(qubit_operand))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// values array is the array that may contain variables that have a specified type\r\n// variables is an object containing key/value pairs with variables and their values\r\n// var_type is a string, if it is \"angle\", then \"angle\" and \"angle_list\" values will be processed\r\nfunction expand_array_vars(values_array, variables, var_type)\r\n{\r\n\r\n    for(let i = 0; i < values_array.length; i++)\r\n    {\r\n        let value = values_array[i];\r\n\r\n        if(value.block_type == block_types.variable_ref)\r\n        {\r\n            // search for variable with the name found in the variable reference\r\n            console.log(value.block_name);\r\n            let variable = variables[value.block_name];\r\n\r\n            // expands the list in-place, then decrements i and restarts the loop at the same index\r\n            if(variable.var_type == (var_type + \"_list\"))\r\n            {\r\n                values_array.splice(i, 1, ...(variable.value));\r\n                i--;\r\n                continue;\r\n            }\r\n\r\n            if(variable.value != undefined)\r\n            {\r\n                values_array[i] = variable.value;\r\n            }// else\r\n            // {\r\n            //     console.log(\"something went wrong with expanding variables\");\r\n            // }\r\n        }\r\n    }\r\n}\r\n\r\n// takes in a measurement block, and key/values pairs of variables\r\n// returns a copy of the object with variables replaced with constants\r\nfunction expand_measurement_variables(block, variables)\r\n{\r\n    let expanded_block = {};\r\n    copy_block(expanded_block, block);\r\n\r\n    if(\"qubit_operands\" in expanded_block)\r\n    {\r\n        expand_array_vars(expanded_block.qubit_operands, variables, \"integer\");\r\n    } // else\r\n    // {\r\n    //     console.log(\"block has missing properties\");\r\n    // }\r\n\r\n    return expanded_block;\r\n}\r\n\r\n\r\nfunction measurement_block_to_qasm(block)\r\n{\r\n    let qasm = \"\";\r\n\r\n    if(block.measure_all)\r\n    {\r\n        qasm = \"measure q -> c;\\n\";\r\n    } else\r\n    {\r\n        qasm += block.qubit_operands.map(operand => `measure q[${operand}] -> c[${operand}];\\n`).join('');\r\n    }\r\n    return qasm;\r\n}\r\n\r\nfunction expand_if_variables(block, variables)\r\n{\r\n    let expanded_block = {};\r\n\r\n    copy_block(expanded_block, block);\r\n\r\n    if(\"values\" in expanded_block)\r\n    {\r\n        expand_array_vars(expanded_block.values, variables, \"integer\");\r\n    } // else\r\n    // {\r\n    //     console.log(\"\\\"if\\\" block has missing properties\");\r\n    // }\r\n\r\n    return expanded_block;\r\n}\r\n\r\nfunction if_block_to_qasm(block, variables, num_qubits)\r\n{\r\n    let gate_qasm = [];\r\n    let qasm = \"\";\r\n\r\n    qasm = `if(c==${block.values[0]}) `;\r\n\r\n    process_blocks(gate_qasm, block.gate, variables, num_qubits, undefined, {built_in_gate: true});\r\n\r\n    qasm += gate_qasm[0][0];\r\n\r\n\r\n\r\n    return qasm;\r\n};\r\n\r\nfunction is_valid_if_block(block)\r\n{\r\n    if(!Number.isInteger(block.values[0]) || block.values < 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// recursively evaluates expression blocks, returns a number\r\nfunction evaluate_expression_block(block, variables, type)\r\n{\r\n    let expanded_block = {};\r\n    copy_block(expanded_block, block);\r\n\r\n    let lhs = expanded_block.operands[0];\r\n    let rhs = expanded_block.operands[1];\r\n\r\n    if(lhs.block_type == block_types.variable_ref || rhs.block_type == block_types.variable_ref)\r\n    {\r\n        expand_array_vars(expanded_block.operands, variables, type);\r\n        lhs = expanded_block.operands[0];\r\n        rhs = expanded_block.operands[1];\r\n    }\r\n\r\n    \r\n    \r\n    if(lhs.block_type == block_types.expression)\r\n    {\r\n        lhs = evaluate_expression_block(lhs, variables, type);\r\n\r\n    } \r\n\r\n    if(rhs.block_type == block_types.expression)\r\n    {\r\n        rhs = evaluate_expression_block(rhs, variables, type);\r\n    }\r\n\r\n    if(typeof(lhs) == \"number\" && typeof(rhs) == \"number\")\r\n    {\r\n        switch(block.operator)\r\n        {\r\n            case \"+\":\r\n            {\r\n                return lhs + rhs;\r\n                break;\r\n            }\r\n            case \"-\":\r\n            {\r\n                return lhs - rhs;\r\n                break;\r\n            }\r\n            default:\r\n            {\r\n                errors.push([error_types.unsupported_operator, block]);\r\n            }\r\n        }\r\n    } else\r\n    {\r\n        // console.log(\"something went wrong with evaluating expressions\");\r\n        // console.log(\"block is\");\r\n        // console.log(block);\r\n    }\r\n\r\n}\r\n\r\nfunction expand_loop_count(block, variables)\r\n{\r\n    let expanded_block = {};\r\n\r\n    copy_block(expanded_block, block);\r\n\r\n    if(expanded_block.loop_count.block_type == block_types.expression)\r\n    {\r\n        expanded_block.loop_count = evaluate_expression_block(expanded_block.loop_count, variables, var_types.int);\r\n    } else\r\n    {\r\n        let num_loops = [expanded_block.num_loops];\r\n        expand_array_vars(num_loops, variables, var_types.int);\r\n        expanded_block.num_loops = num_loops[0]; \r\n    }\r\n\r\n    return expanded_block;\r\n}\r\n\r\n/*\r\n * Performs a deeper copy than object.assign\r\n * This function is intended to be used before variable references are replaced with their values, \r\n * to keep the variable reference intact in the original block\r\n */\r\nfunction copy_block(target, source_block)\r\n{\r\n    Object.assign(target, source_block);\r\n\r\n    for(let property in target)   \r\n    {\r\n        if(Array.isArray(target[property]))\r\n        {\r\n            target[property] = target[property].slice();\r\n        }\r\n    }\r\n}\r\n\r\nfunction loop_block_to_qasm(block, variables, num_qubits, functions)\r\n{\r\n    let gate_qasm = [];\r\n\r\n    for(let i = 0; i < block.num_loops; i++)\r\n    {\r\n        process_blocks(gate_qasm, block.blocks, variables, num_qubits, functions);\r\n    }\r\n\r\n    return gate_qasm;\r\n}\r\n\r\nfunction is_valid_loop_block(block)\r\n{\r\n    if(!Number.isInteger(block.num_loops) || block.num_loops < 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction custom_function_to_qasm(block, variables, num_qubits, functions)\r\n{\r\n    let gate_qasm = [];\r\n\r\n    process_blocks(gate_qasm, block.blocks, variables, num_qubits, functions);\r\n\r\n    return gate_qasm;\r\n}\r\n\r\nfunction n_bit_toffoli_to_qasm(block, variables, num_qubits)\r\n{\r\n    let qasm = [];\r\n    \r\n    let x_gate = [new built_in_gate_block(\"x\", undefined, [], [])];\r\n    \r\n    // invert anticontrols\r\n    for(let i = 0; i < block.anticontrols.length; i++)\r\n    {\r\n        x_gate[0].qubit_operands[0] = block.anticontrols[i];\r\n        \r\n        process_blocks(qasm, x_gate, variables, num_qubits, undefined);\r\n    }\r\n\r\n    let controls = [...block.controls, ...block.anticontrols];\r\n    qasm.push([`ccx q[${controls[0]}], q[${controls[1]}], anc[0];\\n`, block.block_id]);\r\n\r\n    // ccx gates\r\n    for(let i = 2; i < controls.length; i++)\r\n    {\r\n        qasm.push([`ccx q[${controls[i]}], anc[${i-2}], anc[${i-1}];\\n`, block.block_id]);\r\n    }\r\n\r\n    num_qubits[1] = Math.max(num_qubits[1], controls.length-1);\r\n\r\n    qasm.push([`cx anc[${controls.length-1}], q[${block.target}];\\n`]);\r\n\r\n    // ccx gates \r\n    for(let i = controls.length - 1; i >= 2; i--)\r\n    {\r\n        qasm.push([`ccx q[${controls[i]}], anc[${i-2}], anc[${i-1}];\\n`, block.block_id]);\r\n    }\r\n\r\n    qasm.push([`ccx q[${controls[0]}], q[${controls[1]}], anc[0];\\n`, block.block_id]);\r\n\r\n    // invert anticontrols again, to bring them back to normal\r\n    for(let i = 0; i < block.anticontrols.length; i++)\r\n    {\r\n        x_gate[0].qubit_operands[0] = block.anticontrols[i];\r\n        \r\n        process_blocks(qasm, x_gate, variables, num_qubits, undefined);\r\n    }\r\n    return qasm;\r\n}\r\n\r\n\r\nexport {generate_QASM, \r\n    built_in_gate_block, \r\n    var_def_block, \r\n    var_ref_block, \r\n    var_assignment_block, \r\n    measurement_block,\r\n    if_block, \r\n    expression_block,\r\n    loop_block,\r\n    custom_function_def,\r\n    custom_function_ref,\r\n    n_bit_toffoli};\r\n\r\n    export default generate_QASM;","C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\blocks\\customblocks.js",[],"C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\Blockly\\index.js",[],"C:\\Users\\johan\\Desktop\\Quantum-Scratch\\src\\Blockly\\BlocklyComponent.jsx",[],{"ruleId":"90","replacedBy":"91"},{"ruleId":"92","replacedBy":"93"},{"ruleId":"94","severity":1,"message":"95","line":29,"column":35,"nodeType":"96","messageId":"97","endLine":29,"endColumn":40},{"ruleId":"94","severity":1,"message":"98","line":29,"column":42,"nodeType":"96","messageId":"97","endLine":29,"endColumn":47},{"ruleId":"94","severity":1,"message":"99","line":29,"column":49,"nodeType":"96","messageId":"97","endLine":29,"endColumn":55},{"ruleId":"94","severity":1,"message":"100","line":46,"column":9,"nodeType":"96","messageId":"97","endLine":46,"endColumn":13},{"ruleId":"94","severity":1,"message":"101","line":3,"column":9,"nodeType":"96","messageId":"97","endLine":3,"endColumn":22},{"ruleId":"94","severity":1,"message":"102","line":5,"column":3,"nodeType":"96","messageId":"97","endLine":5,"endColumn":16},{"ruleId":"94","severity":1,"message":"103","line":6,"column":3,"nodeType":"96","messageId":"97","endLine":6,"endColumn":16},{"ruleId":"94","severity":1,"message":"104","line":7,"column":3,"nodeType":"96","messageId":"97","endLine":7,"endColumn":23},{"ruleId":"94","severity":1,"message":"105","line":8,"column":3,"nodeType":"96","messageId":"97","endLine":8,"endColumn":20},{"ruleId":"94","severity":1,"message":"106","line":9,"column":3,"nodeType":"96","messageId":"97","endLine":9,"endColumn":11},{"ruleId":"94","severity":1,"message":"107","line":10,"column":3,"nodeType":"96","messageId":"97","endLine":10,"endColumn":19},{"ruleId":"94","severity":1,"message":"108","line":11,"column":3,"nodeType":"96","messageId":"97","endLine":11,"endColumn":13},{"ruleId":"94","severity":1,"message":"109","line":12,"column":3,"nodeType":"96","messageId":"97","endLine":12,"endColumn":22},{"ruleId":"94","severity":1,"message":"110","line":13,"column":3,"nodeType":"96","messageId":"97","endLine":13,"endColumn":22},{"ruleId":"94","severity":1,"message":"111","line":14,"column":3,"nodeType":"96","messageId":"97","endLine":14,"endColumn":24},{"ruleId":"94","severity":1,"message":"112","line":2,"column":5,"nodeType":"96","messageId":"97","endLine":2,"endColumn":24},{"ruleId":"94","severity":1,"message":"102","line":3,"column":5,"nodeType":"96","messageId":"97","endLine":3,"endColumn":18},{"ruleId":"94","severity":1,"message":"103","line":4,"column":5,"nodeType":"96","messageId":"97","endLine":4,"endColumn":18},{"ruleId":"94","severity":1,"message":"104","line":5,"column":5,"nodeType":"96","messageId":"97","endLine":5,"endColumn":25},{"ruleId":"94","severity":1,"message":"105","line":6,"column":5,"nodeType":"96","messageId":"97","endLine":6,"endColumn":22},{"ruleId":"94","severity":1,"message":"106","line":7,"column":5,"nodeType":"96","messageId":"97","endLine":7,"endColumn":13},{"ruleId":"94","severity":1,"message":"107","line":8,"column":5,"nodeType":"96","messageId":"97","endLine":8,"endColumn":21},{"ruleId":"94","severity":1,"message":"108","line":9,"column":5,"nodeType":"96","messageId":"97","endLine":9,"endColumn":15},{"ruleId":"94","severity":1,"message":"109","line":10,"column":5,"nodeType":"96","messageId":"97","endLine":10,"endColumn":24},{"ruleId":"94","severity":1,"message":"110","line":11,"column":5,"nodeType":"96","messageId":"97","endLine":11,"endColumn":24},{"ruleId":"94","severity":1,"message":"111","line":12,"column":5,"nodeType":"96","messageId":"97","endLine":12,"endColumn":26},{"ruleId":"113","severity":1,"message":"114","line":21,"column":19,"nodeType":"115","messageId":"116","endLine":21,"endColumn":37,"fix":"117"},{"ruleId":"94","severity":1,"message":"118","line":22,"column":9,"nodeType":"96","messageId":"97","endLine":22,"endColumn":19},{"ruleId":"94","severity":1,"message":"119","line":26,"column":9,"nodeType":"96","messageId":"97","endLine":26,"endColumn":20},{"ruleId":"120","severity":1,"message":"121","line":34,"column":25,"nodeType":"122","messageId":"123","endLine":34,"endColumn":27},{"ruleId":"113","severity":1,"message":"114","line":56,"column":24,"nodeType":"115","messageId":"116","endLine":56,"endColumn":42,"fix":"124"},{"ruleId":"125","severity":1,"message":"126","line":506,"column":13,"nodeType":"127","messageId":"128","endLine":508,"endColumn":23},{"ruleId":"120","severity":1,"message":"121","line":556,"column":28,"nodeType":"122","messageId":"123","endLine":556,"endColumn":30},{"ruleId":"120","severity":1,"message":"121","line":562,"column":32,"nodeType":"122","messageId":"123","endLine":562,"endColumn":34},{"ruleId":"120","severity":1,"message":"129","line":611,"column":33,"nodeType":"122","messageId":"123","endLine":611,"endColumn":35},{"ruleId":"120","severity":1,"message":"129","line":642,"column":33,"nodeType":"122","messageId":"123","endLine":642,"endColumn":35},{"ruleId":"120","severity":1,"message":"129","line":711,"column":38,"nodeType":"122","messageId":"123","endLine":711,"endColumn":40},{"ruleId":"120","severity":1,"message":"129","line":764,"column":29,"nodeType":"122","messageId":"123","endLine":764,"endColumn":31},{"ruleId":"120","severity":1,"message":"129","line":771,"column":34,"nodeType":"122","messageId":"123","endLine":771,"endColumn":36},{"ruleId":"120","severity":1,"message":"121","line":778,"column":31,"nodeType":"122","messageId":"123","endLine":778,"endColumn":33},{"ruleId":"120","severity":1,"message":"129","line":874,"column":23,"nodeType":"122","messageId":"123","endLine":874,"endColumn":25},{"ruleId":"120","severity":1,"message":"129","line":874,"column":69,"nodeType":"122","messageId":"123","endLine":874,"endColumn":71},{"ruleId":"120","severity":1,"message":"129","line":883,"column":23,"nodeType":"122","messageId":"123","endLine":883,"endColumn":25},{"ruleId":"120","severity":1,"message":"129","line":889,"column":23,"nodeType":"122","messageId":"123","endLine":889,"endColumn":25},{"ruleId":"130","severity":1,"message":"131","line":901,"column":17,"nodeType":"132","messageId":"133","endLine":901,"endColumn":23},{"ruleId":"130","severity":1,"message":"131","line":906,"column":17,"nodeType":"132","messageId":"133","endLine":906,"endColumn":23},{"ruleId":"120","severity":1,"message":"129","line":928,"column":45,"nodeType":"122","messageId":"123","endLine":928,"endColumn":47},"no-native-reassign",["134"],"no-negated-in-lhs",["135"],"no-unused-vars","'Value' is defined but never used.","Identifier","unusedVar","'Field' is defined but never used.","'Shadow' is defined but never used.","'code' is assigned a value but never used.","'generate_QASM' is defined but never used.","'var_def_block' is defined but never used.","'var_ref_block' is defined but never used.","'var_assignment_block' is defined but never used.","'measurement_block' is defined but never used.","'if_block' is defined but never used.","'expression_block' is defined but never used.","'loop_block' is defined but never used.","'custom_function_def' is defined but never used.","'custom_function_ref' is defined but never used.","'n_bit_controlled_gate' is defined but never used.","'built_in_gate_block' is defined but never used.","new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"136","text":"137"},"'num_qubits' is assigned a value but never used.","'qasm_string' is assigned a value but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected",{"range":"138","text":"137"},"no-fallthrough","Expected a 'break' statement before 'default'.","SwitchCase","default","Expected '===' and instead saw '=='.","no-unreachable","Unreachable code.","BreakStatement","unreachableCode","no-global-assign","no-unsafe-negation",[576,576],"()",[1570,1570]]